#User Guide for Indus Integration Framework
=User Guide for Indus Integration Framework=
===IOWA STATE UNIVERSITY===
=INDUS INTEGRATION FRAMEWORK=
=USER'S GUIDE=


==About INDUS==

==What is INDUS?==

INDUS is a [http://www.cild.iastate.edu/~honavar/nsfitr02.html research project] under the direction of [http://www.cs.iastate.edu/~honavar/homepage.html Dr. Vasant Honavar],a professor in the [http://www.cs.iastate.edu/ Computer Science Department Computer Science Department] at [http://www.iastate.edu/ Iowa State University]. INDUS stands for Intelligent Data Understanding System.  It allows users to virtually combine data that is physically spread across many data sources and run queries on that data as though it existed in a single database.  The individual data sources can be Ontology Extended Data Sources and  the system is able to understand  queries using ontological  constructs such as superclass and subclass respectively. The user poses the queries in SQL like syntax (INDUS SQL)  which overloads the left and right angle brackets brackets (“<”  and “>”) to imply subclass and superclass respectively.


==Where can I download/get INDUS?==

INDUS is an open source code and is available as [http://code.google.com/p/indusintegrationframework/ here]. The source is provided as is without any warranty.

==How do/can I contribute?==

You certainly may.  Contact [http://www.cs.iastate.edu/~neeraj/ Neeraj Koul] at neeraj@cs.iastate.edu for further direction.


==Using INDUS==

===Environment Setup===

INDUS requires a database to store temporary results (the results from queries to real data sources).  The information (name, location, and type of database) must be stated in the indus.conf file (described below).  The temporary results are deleted when they are no longer needed.

===INDUS Configuration File===

This is the main configuration file  that sets up the  INDUS framework.  This file has to be named *indus.conf*.  The   possible key/value pairs that can exist in this file are


||------------*Key*---------- || ----------*Value*---------- || ----------------------------------------------------- *Comments*  ------------------------------------------------------||

|| driver_<rdbms> || <driver_class> || Examples of <rdbms>:mysql, postgress, oracle Examples of <driver_class>:com.mysql.jdbc.Driver,org.postgresql. Driver The current version has been tested with mysql ||
|| dbname_indus || <DB_name> || Name of the database in which INDUS will store temporary results ||
|| hostname_indus || <URL_to_DB> || Location of a database in which INDUS will store temporary results ||
|| dbtype_indus || <DB_type> || Type of the database in which INDUS will store temporary results. It must match <rdbms> for one of the driver keys provided above. ||
|| <DB_name> || <username>;<password> || A user name (with read access) and password must be provided for every database ||
|| <view_filename> || <view.txt> || Path to the file  containing configuration files for view. || 
|| <class_name_key> || <class_name> || The possible strings for *class_name_key* can be found in:org.iastate.ailab.qengine.core.factories.solution.SolutionCreator. The value of *class_name* should be the fully qualified class name of a class that implements the same interface as *class_name_key*. ||
|| world_semantics || <open_or_closed> || Future use. Currently Ignored. ||


==User Configuration Files== 

These  includes  configurations files to describe to data sources, ontologies (if any) associated with the attributes in the data sources and schema and ontology mappings to resolve schema and data content heterogeneity. Once these files have been set, the user can query over the disparate data sources as if it is a single datasource


==The UserView File==

This file gives a name to a user view and provides the  paths to the files that describe the DTree, SchemaMap, and  the  Ontology Map associated with this user view (See the appendix for an example of a user view file.).  The structure of  the UserView File is a It is also a Java Properties file and the   the possible key/value pairs that can exist in this file:


|| *Key* || *Value* || *Comments* ||
||UserViewName||<name_of_userview>||Name of this userview||
||DTreeFile||<path_to_DTreeFile>|| Path to the Data Agrregation Tree File||
||SchemaMap||<path_to_schema_map>|| Path to the Schema Map File||
||OntologyMap||<path_to_ontology_map>||	Path to the Ontology Map File||


The Data Aggregation Tree, Schema Map, and Ontology Map files are described below.

==Data AggregationTree File (DTree File)==

The DTreeFile describes the structure of the data aggregation tree.  It is an XML file with following structure ( See the Appendix for an example of a DTreeFile)



|| *Elements* || *Attributes* || *Subelements* || *Comments* ||
||Tree||	||	Node||	This is the root element.||
||node||name, fragmentationType||	dataSourceDescriptor, children, dbInfo||	If the node is a leaf node, it must contain the subelements _dbInfo_ and _dataSourceDescriptor_, otherwise it must contain the subelement _children_ except for the root node, which always has the element _dataSourceDescriptor_.||
||dataSourceDescriptor||	File||   ||  ||		
||children||	joinTable, joincol||	node||	There must be one or more node subelements.  When the fragmentation of the subelement nodes are vertical, the children element must contain the attributes joinTable and joincol.||
||dbInfo||	||host, type||	||	


Description of attributes:

|| *Element: Attribute*	|| *Value* || *Comments* ||
||node: name||	<unrestricted>||	This is used to uniquely identify an element node.  This name must match a name attribute of the datasource element in the Data Source Descriptor file.||
||node: fragmentationType||	<horizontal_or_vertical>||	The fragmentation type of the element node. The value must be of the following: horizontal, vertical||
||dataSourceDescriptor: file||	<path_to_desc>||	Relative path to the file describing the data source of the superelement node.||
||children: joinTable||	<table_name>||	The name of the table containing the joincol attribute for this children element.||
||children: joincol||	<column_name>||	The name of the column on which the data will be joined.  If the value of joincol is the same for two fragmented pieces of data, then each fragment is referring to the same data as a whole.||
||dbInfo: host||	<URL_of_DB>||	Location of database described by the superelement node.||
||dbInfo: type||	<DB_type>||	Type of the database described by the superelement node.  It must match  <rdbms> for one of the driver keys provided above.||


==Schema Map==

The Schema Map is a Java Properties file where the keys are actual table and column names that exist in real databases and their values are the table and column names from the user view (root DTree node) to which they should be mapped.

See the appendix for an example of a Schema Map file.

==Ontology Map==

The Ontology Map is a Java Properties file that will map the names of class ids from the target data source ontologies to the ontology of the user view (root DTree node).

The key/value pairs should follow the following form:
<targetDataSource>@<ontologyId>@<classId> = [EQUAL|SUPER|SUB]@<ontologyI>@<classId>

where the at sign (@) and equals sign (=) are the only literals.  Both <ontologyId> and <classId> must be valid URIs unless the <classId> begins with and underscore (_) in which case the <classId> is assumed to be relative to the <ontologyId>.  <targetDataSource> must be the value of a name attribute for some node element that is describing a real database.  The value of the key/value pair must begin with EQUAL, SUPER, or SUB, which describes the relation of the key to the value where EQUAL is the equlivance class, SUPER is the super class, and SUB is the sub class.

See the appendix for an example of an Ontology Map file.

==DataSource Descriptor==

The Data Source Descriptor file is an XML file that describes the tables, columns, and types of data in those columns for either the virtual database that exists at the root node or for actual databases at leaf nodes.  If the attribute  a column is associated with an ontology, it also containts links to the file (or database)  containing the ontology.

See the appendix for an example of a Data Source Descriptor file.

Here is the structure of a Data Source Descriptor file:

|| *Elements*	|| *Attributes* ||	*Subelements* ||	*Comments*||
||descriptors||   ||		||descriptor||	Must have one or more descriptor subelement.||
||descriptor||	 ||	||datasource||	
||datasource	||name||	table||	Must have one or more table subelements.||
||table||	name||	column||	Must have one or more column subelements.||
||column||	name, type||	operation||	If the values in a column are associated with an ontology, then this element must contain a subelement operation.||
||operation||	type, base, ontology, ontLoc	||||	ontLoc points to the file containing the ontology. ontology  is the URI of the ontology associated with the attribute type is restricted  to value AVH base is the Uri to be appended to the values of the attribute to form concepts in the ontology.||





The following are the major classes in the learning framework.
 * *Classifier:* Interface which every new classifier must implement. Current implementation includes Naïve Bayes and Decision Trees.  

 * *LDInstances:*   A large data set instance which may possibly exceed the size that can be stored in memory. It consists of data descriptor (Desc(D))  and a handle to the  datsource  that answers sufficient statistics.

 * *SSDataSource:*  Interface that every  datasource that  answers sufficient statistics queries will implement.  Current implementation has RelationalDataSource.  Future one will have IndusDataSource.

 * *ReplaceMissingValue:*  An unsupervised filter that replaces missing values by assigning the counts proportionally. Classifiers can call the function in this filter to get modified counts.

 * *Evaluation:*  Evaluates the given classifier on train and test data to return a Confusion matrix. Any implemented Classifier will automatically have access to this.

The Class diagram is shown below

  http://induslearningframework.googlecode.com/files/Classifier_seeded2.jpg

===Execution Flow Overview===
The implementing Classifier Class (say NaiveBayes/ID3) constructs the queries (including path clause )   that  are required for this particular type of  classifier. Any Optimizations (which may depend on passed options) are also performed here.   The constructed  queries  are posed to the  SSDataSource. The Classifier does not need to know how the queries are actually answered as they are abstracted out by SSDataSource Interface ( As an illustration the IndusDataSource will be a virtual data source). The classifier if   required can call the ReplaceMissingValues filter to get the modified counts.

 