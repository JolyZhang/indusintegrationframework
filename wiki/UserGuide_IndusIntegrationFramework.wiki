#User Guide for Indus Integration Framework
=User Guide for Indus Integration Framework=
===IOWA STATE UNIVERSITY===
=INDUS INTEGRATION FRAMEWORK=
=USER'S GUIDE=


==About INDUS==

==What is INDUS?==

INDUS is a [http://www.cild.iastate.edu/~honavar/nsfitr02.html research project] under the direction of [http://www.cs.iastate.edu/~honavar/homepage.html Dr. Vasant Honavar],a professor in the [http://www.cs.iastate.edu/ Computer Science Department Computer Science Department] at [http://www.iastate.edu/ Iowa State University]. INDUS stands for Intelligent Data Understanding System.  It allows users to virtually combine data that is physically spread across many data sources and run queries on that data as though it existed in a single database.  The individual data sources can be Ontology Extended Data Sources and  the system is able to understand  queries using ontological  constructs such as superclass and subclass respectively. The user poses the queries in SQL like syntax (INDUS SQL)  which overloads the left and right angle brackets brackets (“<”  and “>”) to imply subclass and superclass respectively.


==Where can I download/get INDUS?==

INDUS is an open source code and is available as [http://code.google.com/p/indusintegrationframework/ here]. The source is provided as is without any warranty.

==How do/can I contribute?==

You certainly may.  Contact [http://www.cs.iastate.edu/~neeraj/ Neeraj Koul] at neeraj@cs.iastate.edu for further direction.


==Using INDUS==

===Environment Setup===

INDUS requires a database to store temporary results (the results from queries to real data sources).  The information (name, location, and type of database) must be stated in the indus.conf file (described below).  The temporary results are deleted when they are no longer needed.

===INDUS Configuration File===

This is the main configuration file  that sets up the  INDUS framework.  This file has to be named *indus.conf*.  The   possible key/value pairs that can exist in this file are


||------------*Key*---------- || ----------*Value*---------- || ----------------------------------------------------- *Comments*  ------------------------------------------------------||

|| driver_<rdbms> || <driver_class> || Examples of <rdbms>:mysql, postgress, oracle Examples of <driver_class>:com.mysql.jdbc.Driver,org.postgresql. Driver The current version has been tested with mysql ||
|| dbname_indus || <DB_name> || Name of the database in which INDUS will store temporary results ||
|| hostname_indus || <URL_to_DB> || Location of a database in which INDUS will store temporary results ||
|| dbtype_indus || <DB_type> || Type of the database in which INDUS will store temporary results. It must match <rdbms> for one of the driver keys provided above. ||
|| <DB_name> || <username>;<password> || A user name (with read access) and password must be provided for every database ||
|| <view_filename> || <view.txt> || Path to the file  containing configuration files for view. || 
|| <class_name_key> || <class_name> || The possible strings for *class_name_key* can be found in:org.iastate.ailab.qengine.core.factories.solution.SolutionCreator. The value of *class_name* should be the fully qualified class name of a class that implements the same interface as *class_name_key*. ||
|| world_semantics || <open_or_closed> || Future use. Currently Ignored. ||


==User Configuration Files== 

These  includes  configurations files to describe to data sources, ontologies (if any) associated with the attributes in the data sources and schema and ontology mappings to resolve schema and data content heterogeneity. Once these files have been set, the user can query over the disparate data sources as if it is a single datasource


==The UserView File==

This file gives a name to a user view and provides the  paths to the files that describe the DTree, SchemaMap, and  the  Ontology Map associated with this user view (See the appendix for an example of a user view file.).  The structure of  the UserView File is a It is also a Java Properties file and the   the possible key/value pairs that can exist in this file:


|| *Key* || *Value* || *Comments* ||
||UserViewName||<name_of_userview>||Name of this userview||
||DTreeFile||<path_to_DTreeFile>|| Path to the Data Agrregation Tree File||
||SchemaMap||<path_to_schema_map>|| Path to the Schema Map File||
||OntologyMap||<path_to_ontology_map>||	Path to the Ontology Map File||


The Data Aggregation Tree, Schema Map, and Ontology Map files are described below.

==Data AggregationTree File (DTree File)==

The DTreeFile describes the structure of the data aggregation tree.  It is an XML file with following structure ( See the Appendix for an example of a DTreeFile)



|| *Elements* || *Attributes* || *Subelements* || *Comments* ||
||Tree||	||	Node||	This is the root element.||
||node||name, fragmentationType||	dataSourceDescriptor, children, dbInfo||	If the node is a leaf node, it must contain the subelements _dbInfo_ and _dataSourceDescriptor_, otherwise it must contain the subelement _children_ except for the root node, which always has the element _dataSourceDescriptor_.||
||dataSourceDescriptor||	File||   ||  ||		
||children||	joinTable, joincol||	node||	There must be one or more node subelements.  When the fragmentation of the subelement nodes are vertical, the children element must contain the attributes joinTable and joincol.||
||dbInfo||	||host, type||	||	


Description of attributes:

|| *Element: Attribute*	|| *Value* || *Comments* ||
||node: name||	<unrestricted>||	This is used to uniquely identify an element node.  This name must match a name attribute of the datasource element in the Data Source Descriptor file.||
||node: fragmentationType||	<horizontal_or_vertical>||	The fragmentation type of the element node. The value must be of the following: horizontal, vertical||
||dataSourceDescriptor: file||	<path_to_desc>||	Relative path to the file describing the data source of the superelement node.||
||children: joinTable||	<table_name>||	The name of the table containing the joincol attribute for this children element.||
||children: joincol||	<column_name>||	The name of the column on which the data will be joined.  If the value of joincol is the same for two fragmented pieces of data, then each fragment is referring to the same data as a whole.||
||dbInfo: host||	<URL_of_DB>||	Location of database described by the superelement node.||
||dbInfo: type||	<DB_type>||	Type of the database described by the superelement node.  It must match  <rdbms> for one of the driver keys provided above.||


==Schema Map==

The Schema Map is a Java Properties file where the keys are actual table and column names that exist in real databases and their values are the table and column names from the user view (root DTree node) to which they should be mapped.

See the appendix for an example of a Schema Map file.

==Ontology Map==

The Ontology Map is a Java Properties file that will map the names of class ids from the target data source ontologies to the ontology of the user view (root DTree node).

The key/value pairs should follow the following form:
<targetDataSource>@<ontologyId>@<classId> = [EQUAL|SUPER|SUB]@<ontologyI>@<classId>

where the at sign (@) and equals sign (=) are the only literals.  Both <ontologyId> and <classId> must be valid URIs unless the <classId> begins with and underscore (_) in which case the <classId> is assumed to be relative to the <ontologyId>.  <targetDataSource> must be the value of a name attribute for some node element that is describing a real database.  The value of the key/value pair must begin with EQUAL, SUPER, or SUB, which describes the relation of the key to the value where EQUAL is the equlivance class, SUPER is the super class, and SUB is the sub class.

See the appendix for an example of an Ontology Map file.

==DataSource Descriptor==

The Data Source Descriptor file is an XML file that describes the tables, columns, and types of data in those columns for either the virtual database that exists at the root node or for actual databases at leaf nodes.  If the attribute  a column is associated with an ontology, it also containts links to the file (or database)  containing the ontology.

See the appendix for an example of a Data Source Descriptor file.

Here is the structure of a Data Source Descriptor file:

|| *Elements*	|| *Attributes* ||	*Subelements* ||	*Comments*||
||descriptors||   		||descriptor||	Must have one or more descriptor subelement.||
||descriptor||	 	||datasource||	||
||datasource	||name||	table||	Must have one or more table subelements.||
||table||	name||	column||	Must have one or more column subelements.||
||column||	name, type||	operation||	If the values in a column are associated with an ontology, then this element must contain a subelement operation.||
||operation||	type, base, ontology, ontLoc	||  ||	ontLoc points to the file containing the ontology. ontology  is the URI of the ontology associated with the attribute type is restricted  to value AVH base is the Uri to be appended to the values of the attribute to form concepts in the ontology.||


Description of attributes: //TODO finish table

|| *Element: Attribute* || *Value* ||	*Comments* ||
||datasource: name||	<unrestricted>||	This is used to uniquely identify an element datasource.  This name must match a name attribute of the node element in the DTreeFile.||
||table: name||	<table_name>||	Name of the table||
||column: name||	<col_name>||	Name of the column||
||column: type||	<col_type>||	The type of the data in this column.||
||operation: type||	<op_type>||	Fixed value AVH||
||operation: base||	<op_base>||	base is the Uri to be appended to the values of the attribute to form concepts in the ontology||
||operation: ontology||	<op_ontology>||	The  ontology associated with the attribute||
||operation: ontLoc||	<path_to_ontLoc>||	The relative path to the file that describes the ontology.||


==OntLoc File==

The ontLoc file is a file  that contains an  attribute value hierarchy that  can be associated  with an attribute  in the data source. The framework supports a custom format to specify the ontology and can also be configured to read attribute value hierarchies  written in OWL syntax. Developers can add support to attribute value hierarchies in their own custom format by implementing the interface  _org.iastate.ailab.qengine.core.reasoners.impl.OntologyParser .core.reasoners.impl.DefaultOntologyParserImpl_.

The default format for a single ontology is:

Three key/value pairs proceeded by a single semicolon (;). These are for information purposes only

The three key/value pairs are:

|| *Key*||	*Value*||	*Comments*||
||typename||	<attributeName>Type||	attributeName is the column in the table with which ontology is used||
||subTypeOf||	AVH||	 fixed||
||ordername||	ISA||	fixed||

Following the key/value pairs is an optional alias that would be used to shorten the URIs for each item in the ontology.  The alias is a key/value pair that is preceded by the string “xmlns:” (without quotes).  Of course, the key is the alias and the value is a common portion of the URIs for the items in the ontology.

Finally, the structure of the ontology begins with… followed by a open curly brace ({).  Each line between the curly braces is the URI to an item in the ontology.  If using an alias, use double periods (..) to denote the use of the alias.  The rest of the line should complete the URI for an item of the ontology.  All items in the ontology that are refered to in the Ontology Map file must be present.  After the last URI, there must be a closing curly brace (}).

More than one ontology can be within the same file.

Comments begin with the pound sign (#) or double forward slashes (//) and continue until the end of the line.

See the appendix for an example.


==Running Indus==

==Dependant Jars==

Zql.jar -  SQL Parser  (http://www.gibello.com/code/zql/)

meval.jar -  Math Evaluator (http://lts.online.fr/dev/java/math.evaluator/ )

OWL API implementation - (http://owlapi.sourceforge.net/releases.html ), Not Required if you use custom ontology format. 

Log4j -  (http://logging.apache.org/log4j/)

MySQL  drivers for JDBC connectivity (http://www.mysql.com/products/connector/ ) 

Apache Commons Lang ( http://commons.apache.org/lang/ )

The lib package in the source package contains the dependant jars. User’s are required to check for license requirements (if any)

==Command Line==

Coming soon

==API Integration==

The following snippet of code indicates how to integrate into your application(once the configuration files have been set as before).
The relevant classes are 

* org.iastate.ailab.qengine.core.QueryEngine
 
* org.iastate.ailab.qengine.core.QueryResult